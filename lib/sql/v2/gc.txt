# fastweb/lib/sql/v2 [fastweb/lib/sql/v2.test]
.\sql.go:16:6: can inline And as: func(...Node) Node { var rop Node; rop = Node literal; rop.nodes = ops; return rop }
.\sql.go:23:6: can inline Or as: func(...Node) Node { var rop Node; rop = Node literal; rop.nodes = ops; return rop }
.\sql.go:31:6: can inline Eq as: func(string, interface {}) Node { return Node literal }
.\sql.go:35:6: can inline Neq as: func(string, interface {}) Node { return Node literal }
.\sql.go:39:6: can inline In as: func(string, interface {}) Node { return Node literal }
.\sql.go:43:6: can inline Nin as: func(string, interface {}) Node { return Node literal }
.\sql.go:47:6: cannot inline stringOp: unhandled op TYPESW
.\sql.go:50:21: inlining call to strings.(*Builder).WriteString method(*strings.Builder) func(string) (int, error) { strings.b.copyCheck(); strings.b.buf = append(strings.b.buf, strings.s...); return len(strings.s), nil }
.\sql.go:50:21: inlining call to strings.(*Builder).copyCheck method(*strings.Builder) func() { if strings.b.addr == (*strings.Builder)(0) { strings.b.addr = (*strings.Builder)(strings.noescape(unsafe.Pointer(strings.b))) } else { if strings.b.addr != strings.b { panic(string("strings: illegal use of non-zero Builder copied by value")) } } }
.\sql.go:50:21: inlining call to strings.noescape func(unsafe.Pointer) unsafe.Pointer { var strings.x·3 uintptr; strings.x·3 = <N>; strings.x·3 = uintptr(strings.p); return unsafe.Pointer(strings.x·3 ^ uintptr(0)) }
.\sql.go:51:21: inlining call to strings.(*Builder).WriteString method(*strings.Builder) func(string) (int, error) { strings.b.copyCheck(); strings.b.buf = append(strings.b.buf, strings.s...); return len(strings.s), nil }
.\sql.go:51:21: inlining call to strings.(*Builder).copyCheck method(*strings.Builder) func() { if strings.b.addr == (*strings.Builder)(0) { strings.b.addr = (*strings.Builder)(strings.noescape(unsafe.Pointer(strings.b))) } else { if strings.b.addr != strings.b { panic(string("strings: illegal use of non-zero Builder copied by value")) } } }
.\sql.go:51:21: inlining call to strings.noescape func(unsafe.Pointer) unsafe.Pointer { var strings.x·3 uintptr; strings.x·3 = <N>; strings.x·3 = uintptr(strings.p); return unsafe.Pointer(strings.x·3 ^ uintptr(0)) }
.\sql.go:56:21: inlining call to strings.(*Builder).WriteString method(*strings.Builder) func(string) (int, error) { strings.b.copyCheck(); strings.b.buf = append(strings.b.buf, strings.s...); return len(strings.s), nil }
.\sql.go:56:21: inlining call to strings.(*Builder).copyCheck method(*strings.Builder) func() { if strings.b.addr == (*strings.Builder)(0) { strings.b.addr = (*strings.Builder)(strings.noescape(unsafe.Pointer(strings.b))) } else { if strings.b.addr != strings.b { panic(string("strings: illegal use of non-zero Builder copied by value")) } } }
.\sql.go:56:21: inlining call to strings.noescape func(unsafe.Pointer) unsafe.Pointer { var strings.x·3 uintptr; strings.x·3 = <N>; strings.x·3 = uintptr(strings.p); return unsafe.Pointer(strings.x·3 ^ uintptr(0)) }
.\sql.go:57:21: inlining call to strings.(*Builder).WriteString method(*strings.Builder) func(string) (int, error) { strings.b.copyCheck(); strings.b.buf = append(strings.b.buf, strings.s...); return len(strings.s), nil }
.\sql.go:57:21: inlining call to strings.(*Builder).copyCheck method(*strings.Builder) func() { if strings.b.addr == (*strings.Builder)(0) { strings.b.addr = (*strings.Builder)(strings.noescape(unsafe.Pointer(strings.b))) } else { if strings.b.addr != strings.b { panic(string("strings: illegal use of non-zero Builder copied by value")) } } }
.\sql.go:57:21: inlining call to strings.noescape func(unsafe.Pointer) unsafe.Pointer { var strings.x·3 uintptr; strings.x·3 = <N>; strings.x·3 = uintptr(strings.p); return unsafe.Pointer(strings.x·3 ^ uintptr(0)) }
.\sql.go:64:22: inlining call to strings.(*Builder).WriteString method(*strings.Builder) func(string) (int, error) { strings.b.copyCheck(); strings.b.buf = append(strings.b.buf, strings.s...); return len(strings.s), nil }
.\sql.go:64:22: inlining call to strings.(*Builder).copyCheck method(*strings.Builder) func() { if strings.b.addr == (*strings.Builder)(0) { strings.b.addr = (*strings.Builder)(strings.noescape(unsafe.Pointer(strings.b))) } else { if strings.b.addr != strings.b { panic(string("strings: illegal use of non-zero Builder copied by value")) } } }
.\sql.go:64:22: inlining call to strings.noescape func(unsafe.Pointer) unsafe.Pointer { var strings.x·3 uintptr; strings.x·3 = <N>; strings.x·3 = uintptr(strings.p); return unsafe.Pointer(strings.x·3 ^ uintptr(0)) }
.\sql.go:65:22: inlining call to strings.(*Builder).WriteString method(*strings.Builder) func(string) (int, error) { strings.b.copyCheck(); strings.b.buf = append(strings.b.buf, strings.s...); return len(strings.s), nil }
.\sql.go:65:22: inlining call to strings.(*Builder).copyCheck method(*strings.Builder) func() { if strings.b.addr == (*strings.Builder)(0) { strings.b.addr = (*strings.Builder)(strings.noescape(unsafe.Pointer(strings.b))) } else { if strings.b.addr != strings.b { panic(string("strings: illegal use of non-zero Builder copied by value")) } } }
.\sql.go:65:22: inlining call to strings.noescape func(unsafe.Pointer) unsafe.Pointer { var strings.x·3 uintptr; strings.x·3 = <N>; strings.x·3 = uintptr(strings.p); return unsafe.Pointer(strings.x·3 ^ uintptr(0)) }
.\sql.go:66:22: inlining call to strings.(*Builder).WriteString method(*strings.Builder) func(string) (int, error) { strings.b.copyCheck(); strings.b.buf = append(strings.b.buf, strings.s...); return len(strings.s), nil }
.\sql.go:66:22: inlining call to strings.(*Builder).copyCheck method(*strings.Builder) func() { if strings.b.addr == (*strings.Builder)(0) { strings.b.addr = (*strings.Builder)(strings.noescape(unsafe.Pointer(strings.b))) } else { if strings.b.addr != strings.b { panic(string("strings: illegal use of non-zero Builder copied by value")) } } }
.\sql.go:66:22: inlining call to strings.noescape func(unsafe.Pointer) unsafe.Pointer { var strings.x·3 uintptr; strings.x·3 = <N>; strings.x·3 = uintptr(strings.p); return unsafe.Pointer(strings.x·3 ^ uintptr(0)) }
.\sql.go:67:22: inlining call to strings.(*Builder).WriteString method(*strings.Builder) func(string) (int, error) { strings.b.copyCheck(); strings.b.buf = append(strings.b.buf, strings.s...); return len(strings.s), nil }
.\sql.go:67:22: inlining call to strings.(*Builder).copyCheck method(*strings.Builder) func() { if strings.b.addr == (*strings.Builder)(0) { strings.b.addr = (*strings.Builder)(strings.noescape(unsafe.Pointer(strings.b))) } else { if strings.b.addr != strings.b { panic(string("strings: illegal use of non-zero Builder copied by value")) } } }
.\sql.go:67:22: inlining call to strings.noescape func(unsafe.Pointer) unsafe.Pointer { var strings.x·3 uintptr; strings.x·3 = <N>; strings.x·3 = uintptr(strings.p); return unsafe.Pointer(strings.x·3 ^ uintptr(0)) }
.\sql.go:69:22: inlining call to strings.(*Builder).WriteString method(*strings.Builder) func(string) (int, error) { strings.b.copyCheck(); strings.b.buf = append(strings.b.buf, strings.s...); return len(strings.s), nil }
.\sql.go:69:22: inlining call to strings.(*Builder).copyCheck method(*strings.Builder) func() { if strings.b.addr == (*strings.Builder)(0) { strings.b.addr = (*strings.Builder)(strings.noescape(unsafe.Pointer(strings.b))) } else { if strings.b.addr != strings.b { panic(string("strings: illegal use of non-zero Builder copied by value")) } } }
.\sql.go:69:22: inlining call to strings.noescape func(unsafe.Pointer) unsafe.Pointer { var strings.x·3 uintptr; strings.x·3 = <N>; strings.x·3 = uintptr(strings.p); return unsafe.Pointer(strings.x·3 ^ uintptr(0)) }
.\sql.go:70:22: inlining call to strings.(*Builder).WriteString method(*strings.Builder) func(string) (int, error) { strings.b.copyCheck(); strings.b.buf = append(strings.b.buf, strings.s...); return len(strings.s), nil }
.\sql.go:70:22: inlining call to strings.(*Builder).copyCheck method(*strings.Builder) func() { if strings.b.addr == (*strings.Builder)(0) { strings.b.addr = (*strings.Builder)(strings.noescape(unsafe.Pointer(strings.b))) } else { if strings.b.addr != strings.b { panic(string("strings: illegal use of non-zero Builder copied by value")) } } }
.\sql.go:70:22: inlining call to strings.noescape func(unsafe.Pointer) unsafe.Pointer { var strings.x·3 uintptr; strings.x·3 = <N>; strings.x·3 = uintptr(strings.p); return unsafe.Pointer(strings.x·3 ^ uintptr(0)) }
.\sql.go:71:22: inlining call to strings.(*Builder).WriteString method(*strings.Builder) func(string) (int, error) { strings.b.copyCheck(); strings.b.buf = append(strings.b.buf, strings.s...); return len(strings.s), nil }
.\sql.go:71:22: inlining call to strings.(*Builder).copyCheck method(*strings.Builder) func() { if strings.b.addr == (*strings.Builder)(0) { strings.b.addr = (*strings.Builder)(strings.noescape(unsafe.Pointer(strings.b))) } else { if strings.b.addr != strings.b { panic(string("strings: illegal use of non-zero Builder copied by value")) } } }
.\sql.go:71:22: inlining call to strings.noescape func(unsafe.Pointer) unsafe.Pointer { var strings.x·3 uintptr; strings.x·3 = <N>; strings.x·3 = uintptr(strings.p); return unsafe.Pointer(strings.x·3 ^ uintptr(0)) }
.\sql.go:72:22: inlining call to strings.(*Builder).WriteString method(*strings.Builder) func(string) (int, error) { strings.b.copyCheck(); strings.b.buf = append(strings.b.buf, strings.s...); return len(strings.s), nil }
.\sql.go:72:22: inlining call to strings.(*Builder).copyCheck method(*strings.Builder) func() { if strings.b.addr == (*strings.Builder)(0) { strings.b.addr = (*strings.Builder)(strings.noescape(unsafe.Pointer(strings.b))) } else { if strings.b.addr != strings.b { panic(string("strings: illegal use of non-zero Builder copied by value")) } } }
.\sql.go:72:22: inlining call to strings.noescape func(unsafe.Pointer) unsafe.Pointer { var strings.x·3 uintptr; strings.x·3 = <N>; strings.x·3 = uintptr(strings.p); return unsafe.Pointer(strings.x·3 ^ uintptr(0)) }
.\sql.go:77:22: inlining call to strings.(*Builder).WriteString method(*strings.Builder) func(string) (int, error) { strings.b.copyCheck(); strings.b.buf = append(strings.b.buf, strings.s...); return len(strings.s), nil }
.\sql.go:77:22: inlining call to strings.(*Builder).copyCheck method(*strings.Builder) func() { if strings.b.addr == (*strings.Builder)(0) { strings.b.addr = (*strings.Builder)(strings.noescape(unsafe.Pointer(strings.b))) } else { if strings.b.addr != strings.b { panic(string("strings: illegal use of non-zero Builder copied by value")) } } }
.\sql.go:77:22: inlining call to strings.noescape func(unsafe.Pointer) unsafe.Pointer { var strings.x·3 uintptr; strings.x·3 = <N>; strings.x·3 = uintptr(strings.p); return unsafe.Pointer(strings.x·3 ^ uintptr(0)) }
.\sql.go:78:22: inlining call to strings.(*Builder).WriteString method(*strings.Builder) func(string) (int, error) { strings.b.copyCheck(); strings.b.buf = append(strings.b.buf, strings.s...); return len(strings.s), nil }
.\sql.go:78:22: inlining call to strings.(*Builder).copyCheck method(*strings.Builder) func() { if strings.b.addr == (*strings.Builder)(0) { strings.b.addr = (*strings.Builder)(strings.noescape(unsafe.Pointer(strings.b))) } else { if strings.b.addr != strings.b { panic(string("strings: illegal use of non-zero Builder copied by value")) } } }
.\sql.go:78:22: inlining call to strings.noescape func(unsafe.Pointer) unsafe.Pointer { var strings.x·3 uintptr; strings.x·3 = <N>; strings.x·3 = uintptr(strings.p); return unsafe.Pointer(strings.x·3 ^ uintptr(0)) }
.\sql.go:79:22: inlining call to strings.(*Builder).WriteString method(*strings.Builder) func(string) (int, error) { strings.b.copyCheck(); strings.b.buf = append(strings.b.buf, strings.s...); return len(strings.s), nil }
.\sql.go:79:22: inlining call to strings.(*Builder).copyCheck method(*strings.Builder) func() { if strings.b.addr == (*strings.Builder)(0) { strings.b.addr = (*strings.Builder)(strings.noescape(unsafe.Pointer(strings.b))) } else { if strings.b.addr != strings.b { panic(string("strings: illegal use of non-zero Builder copied by value")) } } }
.\sql.go:79:22: inlining call to strings.noescape func(unsafe.Pointer) unsafe.Pointer { var strings.x·3 uintptr; strings.x·3 = <N>; strings.x·3 = uintptr(strings.p); return unsafe.Pointer(strings.x·3 ^ uintptr(0)) }
.\sql.go:80:22: inlining call to strings.(*Builder).WriteString method(*strings.Builder) func(string) (int, error) { strings.b.copyCheck(); strings.b.buf = append(strings.b.buf, strings.s...); return len(strings.s), nil }
.\sql.go:80:22: inlining call to strings.(*Builder).copyCheck method(*strings.Builder) func() { if strings.b.addr == (*strings.Builder)(0) { strings.b.addr = (*strings.Builder)(strings.noescape(unsafe.Pointer(strings.b))) } else { if strings.b.addr != strings.b { panic(string("strings: illegal use of non-zero Builder copied by value")) } } }
.\sql.go:80:22: inlining call to strings.noescape func(unsafe.Pointer) unsafe.Pointer { var strings.x·3 uintptr; strings.x·3 = <N>; strings.x·3 = uintptr(strings.p); return unsafe.Pointer(strings.x·3 ^ uintptr(0)) }
.\sql.go:82:22: inlining call to strings.(*Builder).WriteString method(*strings.Builder) func(string) (int, error) { strings.b.copyCheck(); strings.b.buf = append(strings.b.buf, strings.s...); return len(strings.s), nil }
.\sql.go:82:22: inlining call to strings.(*Builder).copyCheck method(*strings.Builder) func() { if strings.b.addr == (*strings.Builder)(0) { strings.b.addr = (*strings.Builder)(strings.noescape(unsafe.Pointer(strings.b))) } else { if strings.b.addr != strings.b { panic(string("strings: illegal use of non-zero Builder copied by value")) } } }
.\sql.go:82:22: inlining call to strings.noescape func(unsafe.Pointer) unsafe.Pointer { var strings.x·3 uintptr; strings.x·3 = <N>; strings.x·3 = uintptr(strings.p); return unsafe.Pointer(strings.x·3 ^ uintptr(0)) }
.\sql.go:83:22: inlining call to strings.(*Builder).WriteString method(*strings.Builder) func(string) (int, error) { strings.b.copyCheck(); strings.b.buf = append(strings.b.buf, strings.s...); return len(strings.s), nil }
.\sql.go:83:22: inlining call to strings.(*Builder).copyCheck method(*strings.Builder) func() { if strings.b.addr == (*strings.Builder)(0) { strings.b.addr = (*strings.Builder)(strings.noescape(unsafe.Pointer(strings.b))) } else { if strings.b.addr != strings.b { panic(string("strings: illegal use of non-zero Builder copied by value")) } } }
.\sql.go:83:22: inlining call to strings.noescape func(unsafe.Pointer) unsafe.Pointer { var strings.x·3 uintptr; strings.x·3 = <N>; strings.x·3 = uintptr(strings.p); return unsafe.Pointer(strings.x·3 ^ uintptr(0)) }
.\sql.go:84:22: inlining call to strings.(*Builder).WriteString method(*strings.Builder) func(string) (int, error) { strings.b.copyCheck(); strings.b.buf = append(strings.b.buf, strings.s...); return len(strings.s), nil }
.\sql.go:84:22: inlining call to strings.(*Builder).copyCheck method(*strings.Builder) func() { if strings.b.addr == (*strings.Builder)(0) { strings.b.addr = (*strings.Builder)(strings.noescape(unsafe.Pointer(strings.b))) } else { if strings.b.addr != strings.b { panic(string("strings: illegal use of non-zero Builder copied by value")) } } }
.\sql.go:84:22: inlining call to strings.noescape func(unsafe.Pointer) unsafe.Pointer { var strings.x·3 uintptr; strings.x·3 = <N>; strings.x·3 = uintptr(strings.p); return unsafe.Pointer(strings.x·3 ^ uintptr(0)) }
.\sql.go:85:22: inlining call to strings.(*Builder).WriteString method(*strings.Builder) func(string) (int, error) { strings.b.copyCheck(); strings.b.buf = append(strings.b.buf, strings.s...); return len(strings.s), nil }
.\sql.go:85:22: inlining call to strings.(*Builder).copyCheck method(*strings.Builder) func() { if strings.b.addr == (*strings.Builder)(0) { strings.b.addr = (*strings.Builder)(strings.noescape(unsafe.Pointer(strings.b))) } else { if strings.b.addr != strings.b { panic(string("strings: illegal use of non-zero Builder copied by value")) } } }
.\sql.go:85:22: inlining call to strings.noescape func(unsafe.Pointer) unsafe.Pointer { var strings.x·3 uintptr; strings.x·3 = <N>; strings.x·3 = uintptr(strings.p); return unsafe.Pointer(strings.x·3 ^ uintptr(0)) }
.\sql.go:90:6: cannot inline travel: recursive
.\sql.go:95:21: inlining call to strings.(*Builder).WriteString method(*strings.Builder) func(string) (int, error) { strings.b.copyCheck(); strings.b.buf = append(strings.b.buf, strings.s...); return len(strings.s), nil }
.\sql.go:95:21: inlining call to strings.(*Builder).copyCheck method(*strings.Builder) func() { if strings.b.addr == (*strings.Builder)(0) { strings.b.addr = (*strings.Builder)(strings.noescape(unsafe.Pointer(strings.b))) } else { if strings.b.addr != strings.b { panic(string("strings: illegal use of non-zero Builder copied by value")) } } }
.\sql.go:95:21: inlining call to strings.noescape func(unsafe.Pointer) unsafe.Pointer { var strings.x·3 uintptr; strings.x·3 = <N>; strings.x·3 = uintptr(strings.p); return unsafe.Pointer(strings.x·3 ^ uintptr(0)) }
.\sql.go:101:24: inlining call to strings.(*Builder).WriteString method(*strings.Builder) func(string) (int, error) { strings.b.copyCheck(); strings.b.buf = append(strings.b.buf, strings.s...); return len(strings.s), nil }
.\sql.go:101:24: inlining call to strings.(*Builder).copyCheck method(*strings.Builder) func() { if strings.b.addr == (*strings.Builder)(0) { strings.b.addr = (*strings.Builder)(strings.noescape(unsafe.Pointer(strings.b))) } else { if strings.b.addr != strings.b { panic(string("strings: illegal use of non-zero Builder copied by value")) } } }
.\sql.go:101:24: inlining call to strings.noescape func(unsafe.Pointer) unsafe.Pointer { var strings.x·3 uintptr; strings.x·3 = <N>; strings.x·3 = uintptr(strings.p); return unsafe.Pointer(strings.x·3 ^ uintptr(0)) }
.\sql.go:103:24: inlining call to strings.(*Builder).WriteString method(*strings.Builder) func(string) (int, error) { strings.b.copyCheck(); strings.b.buf = append(strings.b.buf, strings.s...); return len(strings.s), nil }
.\sql.go:103:24: inlining call to strings.(*Builder).copyCheck method(*strings.Builder) func() { if strings.b.addr == (*strings.Builder)(0) { strings.b.addr = (*strings.Builder)(strings.noescape(unsafe.Pointer(strings.b))) } else { if strings.b.addr != strings.b { panic(string("strings: illegal use of non-zero Builder copied by value")) } } }
.\sql.go:103:24: inlining call to strings.noescape func(unsafe.Pointer) unsafe.Pointer { var strings.x·3 uintptr; strings.x·3 = <N>; strings.x·3 = uintptr(strings.p); return unsafe.Pointer(strings.x·3 ^ uintptr(0)) }
.\sql.go:107:21: inlining call to strings.(*Builder).WriteString method(*strings.Builder) func(string) (int, error) { strings.b.copyCheck(); strings.b.buf = append(strings.b.buf, strings.s...); return len(strings.s), nil }
.\sql.go:107:21: inlining call to strings.(*Builder).copyCheck method(*strings.Builder) func() { if strings.b.addr == (*strings.Builder)(0) { strings.b.addr = (*strings.Builder)(strings.noescape(unsafe.Pointer(strings.b))) } else { if strings.b.addr != strings.b { panic(string("strings: illegal use of non-zero Builder copied by value")) } } }
.\sql.go:107:21: inlining call to strings.noescape func(unsafe.Pointer) unsafe.Pointer { var strings.x·3 uintptr; strings.x·3 = <N>; strings.x·3 = uintptr(strings.p); return unsafe.Pointer(strings.x·3 ^ uintptr(0)) }
.\sql.go:111:6: cannot inline (*Node).Sql: function too complex: cost 253 exceeds budget 80
.\sql.go:116:24: inlining call to strings.(*Builder).String method(*strings.Builder) func() string { return *(*string)(unsafe.Pointer(&strings.b.buf)) }
.\sql.go:118:14: inlining call to strings.(*Builder).Grow method(*strings.Builder) func(int) { strings.b.copyCheck(); if strings.n < int(0) { panic(string("strings.Builder.Grow: negative count")) }; if cap(strings.b.buf) - len(strings.b.buf) < strings.n { strings.b.grow(strings.n) } }
.\sql.go:118:14: inlining call to strings.(*Builder).copyCheck method(*strings.Builder) func() { if strings.b.addr == (*strings.Builder)(0) { strings.b.addr = (*strings.Builder)(strings.noescape(unsafe.Pointer(strings.b))) } else { if strings.b.addr != strings.b { panic(string("strings: illegal use of non-zero Builder copied by value")) } } }
.\sql.go:118:14: inlining call to strings.noescape func(unsafe.Pointer) unsafe.Pointer { var strings.x·3 uintptr; strings.x·3 = <N>; strings.x·3 = uintptr(strings.p); return unsafe.Pointer(strings.x·3 ^ uintptr(0)) }
.\sql.go:118:14: inlining call to strings.(*Builder).grow method(*strings.Builder) func(int) { var strings.buf·3 []byte; strings.buf·3 = <N>; strings.buf·3 = make([]byte, len(strings.b.buf), int(2) * cap(strings.b.buf) + strings.n); copy(strings.buf·3, strings.b.buf); strings.b.buf = strings.buf·3 }
.\sql.go:120:23: inlining call to strings.(*Builder).String method(*strings.Builder) func() string { return *(*string)(unsafe.Pointer(&strings.b.buf)) }
.\sql_test.go:11:6: can inline foo as: func(*[]interface {}) { *vs = append(*vs, 1) }
.\sql_test.go:15:6: can inline setM as: func(map[string]string) { mp["a"] = "aa" }
.\sql_test.go:19:6: can inline setQ as: func([]int) { q[0] = 100 }
.\sql_test.go:30:6: can inline newBuf as: func(int) *bb { b := new(bb); return b }
.\sql_test.go:36:6: can inline (*bb).WriteString as: method(*bb) func(string) { b.buf = append(b.buf, s...) }
.\sql_test.go:40:6: can inline (*bb).String as: method(*bb) func() string { return *(*string)(unsafe.Pointer(&b.buf)) }
.\sql_test.go:44:6: can inline foo1 as: func([]int) { ss = append(ss, 1) }
.\sql_test.go:48:6: cannot inline Test5: function too complex: cost 277 exceeds budget 80
.\sql_test.go:51:6: inlining call to setQ func([]int) { q[0] = 100 }
.\sql_test.go:52:6: inlining call to setM func(map[string]string) { mp["a"] = "aa" }
.\sql_test.go:54:16: inlining call to newBuf func(int) *bb { b := new(bb); return b }
.\sql_test.go:55:22: inlining call to reflect.TypeOf func(interface {}) reflect.Type { var reflect.eface·3 reflect.emptyInterface; reflect.eface·3 = <N>; reflect.eface·3 = *(*reflect.emptyInterface)(unsafe.Pointer(&reflect.i)); return reflect.toType(reflect.eface·3.typ) }
.\sql_test.go:55:22: inlining call to reflect.toType func(*reflect.rtype) reflect.Type { if reflect.t == (*reflect.rtype)(0) { return nil }; return reflect.Type(reflect.t) }
.\sql_test.go:56:15: inlining call to (*bb).WriteString method(*bb) func(string) { b.buf = append(b.buf, s...) }
.\sql_test.go:68:6: cannot inline Test4: function too complex: cost 356 exceeds budget 80
.\sql_test.go:69:16: inlining call to Eq func(string, interface {}) Node { return Node literal }
.\sql_test.go:69:28: inlining call to Eq func(string, interface {}) Node { return Node literal }
.\sql_test.go:69:13: inlining call to And func(...Node) Node { var rop Node; rop = Node literal; rop.nodes = ops; return rop }
.\sql_test.go:69:43: inlining call to In func(string, interface {}) Node { return Node literal }
.\sql_test.go:69:9: inlining call to Or func(...Node) Node { var rop Node; rop = Node literal; rop.nodes = ops; return rop }
.\sql_test.go:72:8: inlining call to Eq func(string, interface {}) Node { return Node literal }
.\sql_test.go:76:6: cannot inline BenchmarkX1: unhandled op DEFER
.\sql_test.go:82:17: inlining call to Eq func(string, interface {}) Node { return Node literal }
.\sql_test.go:82:29: inlining call to Eq func(string, interface {}) Node { return Node literal }
.\sql_test.go:82:14: inlining call to And func(...Node) Node { var rop Node; rop = Node literal; rop.nodes = ops; return rop }
.\sql_test.go:82:44: inlining call to Eq func(string, interface {}) Node { return Node literal }
.\sql_test.go:82:10: inlining call to Or func(...Node) Node { var rop Node; rop = Node literal; rop.nodes = ops; return rop }
.\sql_test.go:87:6: cannot inline BenchmarkB1: unhandled op FOR
.\sql_test.go:94:18: inlining call to (*bb).WriteString method(*bb) func(string) { b.buf = append(b.buf, s...) }
.\sql_test.go:98:6: cannot inline fxx: function too complex: cost 137 exceeds budget 80
.\sql_test.go:99:16: inlining call to Eq func(string, interface {}) Node { return Node literal }
.\sql_test.go:99:28: inlining call to Eq func(string, interface {}) Node { return Node literal }
.\sql_test.go:99:13: inlining call to And func(...Node) Node { var rop Node; rop = Node literal; rop.nodes = ops; return rop }
.\sql_test.go:99:43: inlining call to Eq func(string, interface {}) Node { return Node literal }
.\sql_test.go:99:9: inlining call to Or func(...Node) Node { var rop Node; rop = Node literal; rop.nodes = ops; return rop }
.\sql_test.go:103:6: cannot inline BenchmarkB2: unhandled op FOR
.\sql.go:16:10: leaking param: ops to result ~r1 level=0
.\sql.go:23:9: leaking param: ops to result ~r1 level=0
.\sql.go:31:9: leaking param: key to result ~r2 level=0
.\sql.go:31:21: leaking param: value to result ~r2 level=0
.\sql.go:35:10: leaking param: key to result ~r2 level=0
.\sql.go:35:22: leaking param: value to result ~r2 level=0
.\sql.go:39:9: leaking param: key to result ~r2 level=0
.\sql.go:39:21: leaking param: value to result ~r2 level=0
.\sql.go:43:10: leaking param: key to result ~r2 level=0
.\sql.go:43:22: leaking param: value to result ~r2 level=0
.\sql.go:47:15: leaking param content: o
.\sql.go:47:24: leaking param content: buffer
.\sql.go:47:49: leaking param content: values
.\sql.go:90:13: leaking param content: node
.\sql.go:90:25: leaking param content: buffer
.\sql.go:90:50: leaking param content: values
.\sql.go:111:7: leaking param content: node
.\sql.go:118:14: make([]byte, len(strings.b.buf), int(2) * cap(strings.b.buf) + strings.n) escapes to heap
.\sql_test.go:11:10: leaking param content: vs
.\sql_test.go:12:14: 1 escapes to heap
.\sql_test.go:15:11: setM mp does not escape
.\sql_test.go:19:11: setQ q does not escape
.\sql_test.go:31:10: new(bb) escapes to heap
.\sql_test.go:36:7: leaking param content: b
.\sql_test.go:36:26: (*bb).WriteString s does not escape
.\sql_test.go:40:7: leaking param: b to result ~r0 level=1
.\sql_test.go:44:11: foo1 ss does not escape
.\sql_test.go:48:12: leaking param: t
.\sql_test.go:49:15: make(map[string]string) escapes to heap
.\sql_test.go:50:14: make([]int, 10) escapes to heap
.\sql_test.go:53:7: Test5 ... argument does not escape
.\sql_test.go:53:7: mp escapes to heap
.\sql_test.go:53:7: q escapes to heap
.\sql_test.go:54:16: new(bb) escapes to heap
.\sql_test.go:55:7: Test5 ... argument does not escape
.\sql_test.go:55:22: reflect.TypeOf(b) escapes to heap
.\sql_test.go:55:22: b escapes to heap
.\sql_test.go:55:22: reflect.Type(reflect.t) escapes to heap
.\sql_test.go:57:7: Test5 ... argument does not escape
.\sql_test.go:57:14: string(b.buf) escapes to heap
.\sql_test.go:57:14: string(b.buf) escapes to heap
.\sql_test.go:68:12: leaking param: t
.\sql_test.go:69:22: 1 escapes to heap
.\sql_test.go:69:34: 300 escapes to heap
.\sql_test.go:69:13: []Node literal escapes to heap
.\sql_test.go:69:55: []int literal escapes to heap
.\sql_test.go:69:55: []int literal escapes to heap
.\sql_test.go:69:9: []Node literal escapes to heap
.\sql_test.go:71:7: Test4 ... argument does not escape
.\sql_test.go:71:7: sql escapes to heap
.\sql_test.go:72:14: 100 escapes to heap
.\sql_test.go:73:7: Test4 ... argument does not escape
.\sql_test.go:73:7: .autotmp_3 escapes to heap
.\sql_test.go:73:7: .autotmp_4 escapes to heap
.\sql_test.go:76:18: BenchmarkX1 b does not escape
.\sql_test.go:79:23: w escapes to heap
.\sql_test.go:82:23: 1 escapes to heap
.\sql_test.go:82:35: 300 escapes to heap
.\sql_test.go:82:14: []Node literal escapes to heap
.\sql_test.go:82:51: 100 escapes to heap
.\sql_test.go:82:10: []Node literal escapes to heap
.\sql_test.go:87:18: BenchmarkB1 b does not escape
.\sql_test.go:93:10: BenchmarkB1 &bb literal does not escape
.\sql_test.go:99:22: 1 escapes to heap
.\sql_test.go:99:34: 300 escapes to heap
.\sql_test.go:99:13: []Node literal escapes to heap
.\sql_test.go:99:50: 100 escapes to heap
.\sql_test.go:99:9: []Node literal escapes to heap
.\sql_test.go:103:18: BenchmarkB2 b does not escape
<autogenerated>:1: (*File).close .this does not escape
<autogenerated>:1: (*File).isdir .this does not escape
# fastweb/lib/sql/v2.test
E:\Temp\go-build818055210\b001\_testmain.go:42:6: can inline init.0 as: func() { testdeps.ImportPath = "fastweb/lib/sql/v2" }
E:\Temp\go-build818055210\b001\_testmain.go:48:6: cannot inline main: function too complex: cost 200 exceeds budget 80
E:\Temp\go-build818055210\b001\_testmain.go:50:24: inlining call to testing.MainStart func(testing.testDeps, []testing.InternalTest, []testing.InternalBenchmark, []testing.InternalExample) *testing.M { testing.Init(); return &testing.M literal }
E:\Temp\go-build818055210\b001\_testmain.go:50:42: testdeps.TestDeps literal escapes to heap
E:\Temp\go-build818055210\b001\_testmain.go:50:24: &testing.M literal escapes to heap
