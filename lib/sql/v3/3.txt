# fastweb/lib/sql/v3 [fastweb/lib/sql/v3.test]
.\bytes.go:9:6: can inline (*noCopy).Lock
.\bytes.go:10:6: can inline (*noCopy).Unlock
.\bytes.go:18:6: can inline NewByteBuffer
.\bytes.go:25:6: can inline (*ByteBuffer).WriteString
.\bytes.go:38:6: can inline (*ByteBuffer).Len
.\bytes.go:42:6: can inline (*ByteBuffer).Cap
.\bytes.go:46:6: can inline (*ByteBuffer).WriteBytes
.\bytes.go:59:6: can inline (*ByteBuffer).String
.\sql_test.go:11:6: can inline (*ByteSlice).WriteString
.\sql_test.go:16:6: can inline fy
.\sql_test.go:17:16: inlining call to (*ByteSlice).WriteString
.\sql_test.go:25:22: inlining call to NewByteBuffer
.\sql_test.go:26:17: inlining call to (*ByteBuffer).WriteString
.\sql_test.go:27:17: inlining call to (*ByteBuffer).WriteString
.\sql_test.go:37:29: inlining call to bytess.NewByteBuffer
.\sql_test.go:38:17: inlining call to bytess.(*ByteBuffer).WriteString
.\sql_test.go:50:28: inlining call to bytess.NewByteBuffer
.\sql_test.go:51:16: inlining call to bytess.(*ByteBuffer).WriteString
.\sql_test.go:52:16: inlining call to bytess.(*ByteBuffer).WriteString
.\sql_test.go:53:17: inlining call to bytess.(*ByteBuffer).String
.\sql_test.go:54:14: inlining call to bytess.(*ByteBuffer).Cap
.\sql_test.go:54:24: inlining call to bytess.(*ByteBuffer).Len
.\bytes.go:18:20: leaking param: bs
.\bytes.go:21:3: &ByteBuffer literal escapes to heap
.\bytes.go:25:7: (*ByteBuffer).WriteString b does not escape
.\bytes.go:25:34: (*ByteBuffer).WriteString s does not escape
.\bytes.go:27:14: make([]byte, b.len * 2 + len(s)) escapes to heap
.\bytes.go:38:7: (*ByteBuffer).Len b does not escape
.\bytes.go:42:7: (*ByteBuffer).Cap b does not escape
.\bytes.go:46:7: (*ByteBuffer).WriteBytes b does not escape
.\bytes.go:46:33: (*ByteBuffer).WriteBytes s does not escape
.\bytes.go:48:14: make([]byte, b.len * 2 + len(s)) escapes to heap
.\bytes.go:59:7: leaking param: b to result ~r0 level=1
.\sql_test.go:11:7: (*ByteSlice).WriteString b does not escape
.\sql_test.go:11:33: (*ByteSlice).WriteString s does not escape
.\sql_test.go:16:9: fy bs does not escape
.\sql_test.go:22:18: BenchmarkC2 b does not escape
.\sql_test.go:25:22: BenchmarkC2 &ByteBuffer literal does not escape
.\sql_test.go:26:17: make([]byte, b.len * 2 + len(s)) escapes to heap
.\sql_test.go:27:17: make([]byte, b.len * 2 + len(s)) escapes to heap
.\sql_test.go:35:18: BenchmarkC1 b does not escape
.\sql_test.go:37:34: BenchmarkC1 make([]byte, 10) does not escape
.\sql_test.go:37:29: BenchmarkC1 &bytess.ByteBuffer literal does not escape
.\sql_test.go:38:17: make([]byte, bytess.b.len * int(2) + len(bytess.s)) escapes to heap
.\sql_test.go:47:12: leaking param: t
.\sql_test.go:50:33: make([]byte, 10) escapes to heap
.\sql_test.go:50:28: Test8 &bytess.ByteBuffer literal does not escape
.\sql_test.go:51:16: make([]byte, bytess.b.len * int(2) + len(bytess.s)) escapes to heap
.\sql_test.go:52:16: make([]byte, bytess.b.len * int(2) + len(bytess.s)) escapes to heap
.\sql_test.go:53:7: Test8 ... argument does not escape
.\sql_test.go:53:17: bs.String() escapes to heap
.\sql_test.go:54:7: Test8 ... argument does not escape
.\sql_test.go:54:14: bs.Cap() escapes to heap
.\sql_test.go:54:24: bs.Len() escapes to heap
<autogenerated>:1: (*ByteBuffer).Lock .this does not escape
<autogenerated>:1: (*ByteBuffer).Unlock .this does not escape
# fastweb/lib/sql/v3.test
E:\Temp\go-build545356050\b001\_testmain.go:38:6: can inline init.0
E:\Temp\go-build545356050\b001\_testmain.go:46:24: inlining call to testing.MainStart
E:\Temp\go-build545356050\b001\_testmain.go:46:42: testdeps.TestDeps literal escapes to heap
E:\Temp\go-build545356050\b001\_testmain.go:46:24: &testing.M literal escapes to heap
